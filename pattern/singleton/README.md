懒加载的单例模式适合以下场景：

1. 资源消耗较大：当创建一个对象的过程需要较多的资源或时间时，使用懒加载的单例模式可以延迟对象的创建，避免不必要的资源消耗。例如，数据库连接池、网络连接管理器等场景。

2. 频繁创建与销毁代价高的对象：在某些情况下，频繁创建和销毁对象会带来性能损耗，使用懒加载的单例模式可以复用对象，避免重复创建和销毁。例如，日志记录器、线程池等场景。

3. 全局唯一性：在需要确保某个对象在系统中只存在一个实例的情况下，可以使用懒加载的单例模式。这样可以避免多个实例产生的数据不一致性或冲突。例如，配置管理器、缓存管理器等场景。

4. 节省系统资源：当系统资源有限，且需要共享的对象较多时，使用懒加载的单例模式可以减少对象的创建数量，从而节省系统资源。例如，线程池、连接池等场景。

需要注意的是，懒加载的单例模式可能引入线程安全性问题，需要在实现时考虑并发访问的情况，并进行适当的线程同步措施，以确保单例对象的正确性和一致性。

sync.Once的主要原理是基于原子操作和互斥锁。它内部维护了一个done标志，用于记录函数是否已经执行过。当多个goroutine并发调用sync.Once的Do方法时，只有第一个goroutine会执行传递的函数，而其他的goroutine会被阻塞直到第一个goroutine执行完成。

一旦第一个goroutine执行完成并且done标志被设置，后续的goroutine会直接跳过函数执行部分，从而实现只执行一次的效果。这样能够避免竞态条件（race condition）和其他并发问题。